(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[321],{92011:(e,t)=>{"use strict";var s=t.uO={};s.read=function(e,t){return e.readFields(s._readField,{chunk:[],quantized_chunk:[]},t)},s._readField=function(e,t,s){1===e?t.chunk.push(a.read(s,s.readVarint()+s.pos)):2===e&&t.quantized_chunk.push(d.read(s,s.readVarint()+s.pos))},s.write=function(e,t){if(e.chunk)for(var s=0;s<e.chunk.length;s++)t.writeMessage(1,a.write,e.chunk[s]);if(e.quantized_chunk)for(s=0;s<e.quantized_chunk.length;s++)t.writeMessage(2,d.write,e.quantized_chunk[s])};var r={};r.read=function(e,t){return e.readFields(r._readField,{xyz:[],uv:[]},t)},r._readField=function(e,t,s){1===e?s.readPackedFloat(t.xyz):2===e&&s.readPackedFloat(t.uv)},r.write=function(e,t){e.xyz&&t.writePackedFloat(1,e.xyz),e.uv&&t.writePackedFloat(2,e.uv)};var i={};i.read=function(e,t){return e.readFields(i._readField,{faces:[]},t)},i._readField=function(e,t,s){1===e&&s.readPackedVarint(t.faces)},i.write=function(e,t){e.faces&&t.writePackedVarint(1,e.faces)};var a={};a.read=function(e,t){return e.readFields(a._readField,{vertices:null,faces:null,chunk_name:"",material_name:""},t)},a._readField=function(e,t,s){1===e?t.vertices=r.read(s,s.readVarint()+s.pos):2===e?t.faces=i.read(s,s.readVarint()+s.pos):3===e?t.chunk_name=s.readString():4===e&&(t.material_name=s.readString())},a.write=function(e,t){e.vertices&&t.writeMessage(1,r.write,e.vertices),e.faces&&t.writeMessage(2,i.write,e.faces),e.chunk_name&&t.writeStringField(3,e.chunk_name),e.material_name&&t.writeStringField(4,e.material_name)};var o={};o.read=function(e,t){return e.readFields(o._readField,{quantization:0,translation:[],x:[],y:[],z:[]},t)},o._readField=function(e,t,s){1===e?t.quantization=s.readFloat():2===e?s.readPackedFloat(t.translation):3===e?s.readPackedSVarint(t.x):4===e?s.readPackedSVarint(t.y):5===e&&s.readPackedSVarint(t.z)},o.write=function(e,t){e.quantization&&t.writeFloatField(1,e.quantization),e.translation&&t.writePackedFloat(2,e.translation),e.x&&t.writePackedSVarint(3,e.x),e.y&&t.writePackedSVarint(4,e.y),e.z&&t.writePackedSVarint(5,e.z)};var n={};n.read=function(e,t){return e.readFields(n._readField,{name:"",quantization:0,u:[],v:[]},t)},n._readField=function(e,t,s){1===e?t.name=s.readString():2===e?t.quantization=s.readFloat():3===e?s.readPackedSVarint(t.u):4===e&&s.readPackedSVarint(t.v)},n.write=function(e,t){e.name&&t.writeStringField(1,e.name),e.quantization&&t.writeFloatField(2,e.quantization),e.u&&t.writePackedSVarint(3,e.u),e.v&&t.writePackedSVarint(4,e.v)};var h={};h.read=function(e,t){return e.readFields(h._readField,{faces:[]},t)},h._readField=function(e,t,s){1===e&&s.readPackedSVarint(t.faces)},h.write=function(e,t){e.faces&&t.writePackedSVarint(1,e.faces)};var d={};d.read=function(e,t){return e.readFields(d._readField,{chunk_name:"",material_name:"",vertices:null,uvs:[],faces:null},t)},d._readField=function(e,t,s){1===e?t.chunk_name=s.readString():2===e?t.material_name=s.readString():3===e?t.vertices=o.read(s,s.readVarint()+s.pos):4===e?t.uvs.push(n.read(s,s.readVarint()+s.pos)):5===e&&(t.faces=i.read(s,s.readVarint()+s.pos))},d.write=function(e,t){if(e.chunk_name&&t.writeStringField(1,e.chunk_name),e.material_name&&t.writeStringField(2,e.material_name),e.vertices&&t.writeMessage(3,o.write,e.vertices),e.uvs)for(var s=0;s<e.uvs.length;s++)t.writeMessage(4,n.write,e.uvs[s]);e.faces&&t.writeMessage(5,i.write,e.faces)}},26203:(e,t,s)=>{"use strict";s.r(t),s.d(t,{default:()=>MeshQueryModule});var r=s(47724),i=s(17399),a=s(86488),o=s(26627);const n=(...e)=>function(t){return e.every((e=>e(t)))};var h=s(51245),d=s(2212);class MeshQueryModule extends r.Y{constructor(){super(...arguments),this.name="mesh-query"}async init(e,t){const[s,r,n]=await Promise.all([t.market.waitForData(o.i),t.market.waitForData(a.Z),t.getModule(i.default)]);this.raycaster=n,this.floorData=s,this.roomData=r}nearestMeshInfoOnFloor(e,t){const s=n(h.$4.isRoomMesh,h.$4.matchesFloorId(t));return this.raycaster.picking.nearest((new d.Vector3).set(e.x,e.y,e.z),s)}nearestMeshInfo(e){return this.raycaster.picking.nearest((new d.Vector3).set(e.x,e.y,e.z),h.$4.isRoomMesh)}inferMeshIdsFromPoint(e,t){const s=!e.roomId||!this.roomData.get(e.roomId),r=!e.floorId||!this.floorData.hasFloor(e.floorId);if(s||r){const i=r?h.$4.isRoomMesh:n(h.$4.isRoomMesh,h.$4.matchesFloorId(e.floorId)),a=this.raycaster.picking.nearest((new d.Vector3).set(t.x,t.y,t.z),i);a&&h.$4.isRoomMesh(a.object)?(this.log.debug("data-fixup:",s?{roomId:a.object.roomId,prev:e.roomId}:"",r?{floorId:a.object.floorId,prev:e.floorId}:"",{data:e}),s&&(e.roomId=a.object.roomId),r&&(e.floorId=a.object.floorId)):this.log.warn("Nearest Room/Floor not found for:",{point:t,data:e,invalidRoomId:s,invalidFloorId:r})}return e}}},33512:(e,t,s)=>{"use strict";s.d(t,{Z:()=>MeshTrimData});var r=s(32770),i=s(75256),a=s(64781),o=s(60697),n=s(56247),h=s(88512),d=s(28719),u=s(44283);const l=new h.Z("MeshTrimData");class MeshTrimData extends r.V{constructor(e,t){super(),this.maxTrimsPerFloor=n.t,this.maxAllFloorsTrims=n.t,this.numberOfTrims=0,this.meshTrimsByMeshGroup=new a.v,this.meshTrimsById=new a.v,this.onMeshGroupChangedCallbacks=new Set,this.onMeshTrimChangedCallbacks=new Set,this.updateMeshTrim=e=>{for(const t of this.onMeshTrimChangedCallbacks)t(e)},this.notifyMeshGroupChanges=e=>{for(const t of this.onMeshGroupChangedCallbacks)t(e)};for(const e of t){const t=e.meshGroup,s=new i.d;this.meshTrimsByMeshGroup.set(`${t}`,s)}1===t.length&&(this.singleFloorMeshGroup=t[0].meshGroup),this.meshTrimsByMeshGroup.set(`${o.e}`,new i.d);try{this.add(...Object.values(e))}catch(e){}}add(...e){const t=new Set;let s=!1;if(this.meshTrimsById.atomic((()=>{this.meshTrimsByMeshGroup.atomic((()=>{for(const r of e){void 0!==this.singleFloorMeshGroup&&(r.meshGroup=this.singleFloorMeshGroup);const e=r.meshGroup===o.e,a=`${r.meshGroup}`;this.meshTrimsByMeshGroup.has(a)||this.meshTrimsByMeshGroup.set(a,new i.d);const n=this.meshTrimsByMeshGroup.get(a);n.length<(e?this.maxAllFloorsTrims:this.maxTrimsPerFloor)?(n.push(r),this.meshTrimsById.set(r.id,r),t.add(r.meshGroup),r.onChanged(this.updateMeshTrim)):(l.debugWarn("Trims exceed floor limit (trimId, meshGroup):",r.id,r.meshGroup),s=!0)}}))})),t.forEach((e=>{const t=this.meshTrimsByMeshGroup.get(`${e}`);this.sortList(t),this.reassignIndexes(t),this.notifyMeshGroupChanges(e)})),this.updateDerivedProperties(),this.commit(),s)throw new d.M("Exceeding max trims")}delete(...e){const t=new Set;this.meshTrimsByMeshGroup.atomic((()=>{for(const s of e){const e=this.meshTrimsByMeshGroup.get(`${s.meshGroup}`),r=e.indexOf(s);if(r>=0){e.splice(r,1)[0].enabled=!1,t.add(s.meshGroup),s.removeOnChanged(this.updateMeshTrim)}else l.error("Could not delete mesh trim:"+s.id)}})),t.forEach((e=>{const t=this.meshTrimsByMeshGroup.get(`${e}`);this.reassignIndexes(t),this.notifyMeshGroupChanges(e)})),this.meshTrimsById.atomic((()=>{e.forEach((e=>{this.meshTrimsById.delete(e.id)}))})),this.updateDerivedProperties(),this.commit()}updateDerivedProperties(){this.numberOfTrims=this.meshTrimsById.length,this.maxTrimsPerFloor=n.t-this.meshTrimsByMeshGroup.get(`${o.e}`).length,this.maxAllFloorsTrims=n.t-this.getLongestTrimListLength()}onMeshGroupChanged(e){return(0,u.k1)((()=>this.onMeshGroupChangedCallbacks.add(e)),(()=>this.onMeshGroupChangedCallbacks.delete(e)))}onMeshTrimChanged(e){return(0,u.k1)((()=>this.onMeshTrimChangedCallbacks.add(e)),(()=>this.onMeshTrimChangedCallbacks.delete(e)))}getTrimById(e){return this.meshTrimsById.get(e)}getTrim(e,t){return this.meshTrimsByMeshGroup.has(`${e}`)?this.meshTrimsByMeshGroup.get(`${e}`).get(t):null}getTrimsForMeshGroup(e){return this.meshTrimsByMeshGroup.has(`${e}`)?this.meshTrimsByMeshGroup.get(`${e}`).values():[]}reassignIndexes(e){e.forEach(((e,t)=>{e.index=t}))}sortList(e){e.sort(((e,t)=>e.index-t.index))}getLongestTrimListLength(){let e=0;return this.meshTrimsByMeshGroup.keys.forEach((t=>{if(t===`${o.e}`)return;const s=this.meshTrimsByMeshGroup.get(t);e=Math.max(s.length,e)})),e}}},28719:(e,t,s)=>{"use strict";s.d(t,{M:()=>TooManyTrimsError});var r=s(31102);class TooManyTrimsError extends r.y{constructor(e){super(e),this.name="TooManyTrimsError"}}},17915:(e,t,s)=>{"use strict";s.d(t,{z:()=>Chunk});var r=s(2212),i=s(56247),a=s(67078);class ChunkMaterial extends a.b{constructor(e,t,s){const r={};for(const e of t)r[e]=!0;super({extensions:{derivatives:!0},fragmentShader:i.Z.modelChunk.fragmentShader,vertexShader:i.Z.modelChunk.vertexShader,uniforms:s,name:e,defines:r}),this.capabilities=t}}var o=s(22377),n=s(19131),h=s(10757),d=s(2388),u=s(44283),l=s(17916),c=s(75351);function m(e,t){return null==t?t:t.isVector3||t.isVector4||t.isMatrix3||t.isMatrix4||t.isColor?null!=e?(e.copy(t),e):t.clone():t}let p,g=1;try{p=(0,n.k7)(0,0)}catch(e){}let f=1/0;const y=4+i.t,M=[{key:o.h.PanoTextureTransition,enabled:function(e){return e.progress.value>0&&e.progress.value<1&&e.pano0Map.value!==e.pano1Map.value},dependsOn:[o.h.PanoTexture],uniformsUsed:["progress","pano0Map","pano1Map"]},{key:o.h.PanoTexture,enabled:function(e){return e.panoOpacity.value>0},dependsOn:[],uniformsUsed:["panoOpacity"]},{key:o.h.ColorOverlay,enabled:function(e){return null!==e.colorOverlay.value},dependsOn:[],uniformsUsed:["colorOverlay"]},{key:o.h.MeshPreviewSphere,enabled:function(e){return null!==e.meshPreviewCenter.value},dependsOn:[o.h.MeshTexture],uniformsUsed:[]},{key:o.h.MeshTexture,enabled:function(e){return e.meshOpacity.value>0&&e.map.value},dependsOn:[],uniformsUsed:["meshOpacity","map"]},{key:o.h.Wireframe,enabled:function(e){return!1},dependsOn:[],uniformsUsed:[]},{key:o.h.FlatShading,enabled:function(e){return!1},dependsOn:[],uniformsUsed:[]},{key:o.h.PanoOverlay,enabled:function(e){return!!e.overlay0Map.value},dependsOn:[o.h.PanoTexture],uniformsUsed:["overlay0Map"]},{key:o.h.PanoOverlayTransition,enabled:function(e){return!!(e.progress.value>0&&e.progress.value<1&&e.overlay0Map.value&&e.overlay1Map.value&&e.overlay0Map.value!==e.overlay1Map.value)},dependsOn:[o.h.PanoOverlay,o.h.PanoTexture,o.h.PanoTextureTransition],uniformsUsed:["progress","overlay0Map","overlay1Map"]},{key:o.h.MeshTrimVertex,enabled:function(e){return f>y&&e.meshTrimMatrices.value.some((e=>!!e.elements[15]))},dependsOn:[o.h.MeshTexture],uniformsUsed:["meshTrimMatrices","meshTrimsDiscardContents"]},{key:o.h.MeshTrimPixel,enabled:function(e){return f<=y&&e.meshTrimMatrices.value.some((e=>!!e.elements[15]))},dependsOn:[o.h.MeshTexture],uniformsUsed:["meshTrimMatrices","meshTrimsDiscardContents"]}],x=new Set(M.map((e=>e.uniformsUsed)).reduce(((e,t)=>e.concat(t)),[])),T=["progress","panoOpacity","meshOpacity","pano0Map","pano0Position","pano0Matrix1","pano0Matrix2","pano1Map","pano1Position","pano1Matrix1","pano1Matrix2","overlay0Map","overlay0Matrix","overlay1Map","overlay1Matrix"];class Chunk{constructor(e,t,s,a="",o=!1){if(this.meshGroup=e,this.meshSubgroup=t,this.geometry=s,this.textureName=a,this.id=g++,this.name="",this.lod=l.V.Standard,this.renderingMode=c.S.Standard,this.capabilityOverrides={},this.onMaterialUpdate=new Set,this.uniformCache=Chunk.getUniformDefaults(),this.opacity=1,this.temp={m1:new r.Matrix4,m2:new r.Matrix4,quat:new r.Quaternion},!Chunk.modeMaterials){Chunk.modeMaterials={};const e=r.UniformsUtils.clone(i.Z.depth.uniforms);Chunk.modeMaterials[c.S.Depth]=new r.RawShaderMaterial({fragmentShader:i.Z.depth.fragmentShader,vertexShader:i.Z.depth.vertexShader,uniforms:e,side:r.FrontSide,name:"materialDepth"});const t=r.UniformsUtils.clone(i.Z.modelOutside.uniforms);t.opacity.value=.2,Chunk.modeMaterials[c.S.Transparent]=new r.RawShaderMaterial({fragmentShader:i.Z.modelOutside.fragmentShader,vertexShader:i.Z.modelOutside.vertexShader,uniforms:t,side:r.FrontSide,transparent:!0,name:"materialTransparent"});const s=r.UniformsUtils.clone(i.Z.modelOutside.uniforms);s.opacity.value=.5,s.colorOverlay.value.set(1,1,1,1),Chunk.modeMaterials[c.S.Wireframe]=new r.RawShaderMaterial({fragmentShader:i.Z.modelOutside.fragmentShader,vertexShader:i.Z.modelOutside.vertexShader,uniforms:s,side:r.FrontSide,transparent:!0,wireframe:!0,name:"materialWireframe"})}this.standardMaterial=this.getChunkMaterial(this.getCapabilities(),!1,!1),this._material=this.standardMaterial,o&&this.setMaterialsUniform(Chunk.globalUniforms)}static setSide(e){Chunk.side=e;for(const t in Chunk.chunkMaterials){Chunk.chunkMaterials[t].name.includes("f")||(Chunk.chunkMaterials[t].side=e)}}static setMaxVaryings(e){f=e}static disposeShared(){for(const e in Chunk.chunkMaterials){const t=Chunk.chunkMaterials[e];for(const e in t.uniforms)"t"===t.uniforms[e].type&&t.uniforms[e].value.dispose();t.dispose(),delete Chunk.chunkMaterials[e]}}dispose(){const{uniformCache:e,geometry:t,embeddedTexture:s}=this;for(const t in e)"t"===e[t].type&&e[t].value&&e[t].value.dispose(),delete e[t];t.dispose(),s&&(s.dispose(),this.embeddedTexture=null)}static getUniformDefaults(){const e={};for(const t in i.Z.modelChunk.uniforms){const s=r.UniformsUtils.clone(i.Z.modelChunk.uniforms[t]);for(const t in s)e[t]=s[t]}return e}set material(e){if(this._material!==e&&this.onMaterialUpdate)for(const t of this.onMaterialUpdate.values())t(e);this._material=e}get material(){return this._material}notifyOnMaterialUpdated(e){return(0,u.k1)((()=>this.onMaterialUpdate.add(e)),(()=>this.onMaterialUpdate.delete(e)),!0)}setMeshTexture(e){this.setMaterialsUniform({map:e})}getColorOverlay(){return this._colorOverlay}setColorOverlay(e){this._colorOverlay!==e&&(this.setMaterialsUniform({colorOverlay:e}),this._colorOverlay=e)}setMeshTextureOpacity(e){e!==this._meshTextureOpacity&&(this.setMaterialsUniform({meshOpacity:e,panoOpacity:1-e}),this._meshTextureOpacity=e)}setProgress(e){this._progress!==e&&(this.setMaterialsUniform({progress:e}),this._progress=e)}opacityParams(){return{needTransparent:this.opacity<d.xx.FADE_OPAQUE,needDepthWrite:this.opacity>=d.xx.FADE_DEPTH_WRITE_THRESHOLD}}setOpacity(e){this.opacity=e;const{needTransparent:t,needDepthWrite:s}=this.opacityParams();return this.onOpacityUpdate&&this.onOpacityUpdate(e),t!==this._material.transparent||s!==this._material.depthWrite}getOpacity(){return this.opacity}setTime(e){this.renderingMode===c.S.Wireframe&&this.setMaterialsUniform({time:e})}setTransparentDiscard(e){this.setMaterialsUniform({transparentDiscardDist:e})}setMeshPreviewSphere(e,t=.3){this.setMaterialsUniform({meshPreviewCenter:e,meshPreviewSize:t})}setWireframe(e){if(e){if(this.geometry.getIndex()){const e=this.geometry;e.boundsTree&&(e.boundsTree.geometry=this.geometry.clone()),this.geometry.copy(this.geometry.toNonIndexed())}(0,n.ko)(this.geometry)}this.overrideCapability(o.h.Wireframe,e)}setFlatShading(e){e&&this.geometry.computeVertexNormals(),this.overrideCapability(o.h.FlatShading,e)}getCapabilities(){const e=new Set;for(const t in this.capabilityOverrides)this.capabilityOverrides[t]&&e.add(t);for(const t of M)if(!e.has(t.key)&&t.enabled(this.uniformCache)){e.add(t.key);for(const s of t.dependsOn)e.add(s)}return e}overrideCapability(e,t){this.capabilityOverrides[e]=t,this.updateMaterialCapabilities()}updateMaterialCapabilities(){const e=this.getCapabilities(),t=this.standardMaterial,{needTransparent:s,needDepthWrite:r}=this.opacityParams();if((0,h.TH)(t.capabilities,e)&&s===t.transparent&&r===t.depthWrite)return this._material;const i=this.getChunkMaterial(e,s,r);return this.standardMaterial=i,this.renderingMode===c.S.Standard&&(this.material=i),this._material}getChunkMaterial(e,t,s){let i="chunkMaterial_";for(const t of M)i+=e.has(t.key)?"1":"0";const a=-1===this.meshGroup&&-1===this.meshSubgroup;if(a?i+="f":(i+=t?"1":"0",i+=s?"1":"0"),!Chunk.chunkMaterials[i]){const o=new ChunkMaterial(i,e,this.getUniformsForCapabilities(e));a?(o.side=r.BackSide,o.transparent=!0,o.depthWrite=!1):(o.transparent=t,o.depthWrite=s,o.side=Chunk.side),Chunk.chunkMaterials[i]=o}return Chunk.chunkMaterials[i]}getUniformsForCapabilities(e){const t={};for(const s of e){const e=i.Z.modelChunk.uniforms[s];for(const s in e)t[s]=r.UniformsUtils.clone(this.uniformCache[s])}return t}setMaterialsUniform(e,t=!1){let s,r=!1;const i=this.uniformCache.meshPreviewCenter.value;for(const a in e){let o=!1;const n=e[a];if(o="meshPreviewCenter"!==a?o||x.has(a):o||null===i!=(null===n),!(a in this.uniformCache))throw new Error(`Uniform ${a} does not exist in Chunk`);const h=this.uniformCache[a];h.value!==n&&(h.value=m(h.value,n),"opacity"===a&&(s=n),t&&T.includes(a)&&(Chunk.globalUniforms[a]=m(Chunk.globalUniforms[a],n)),r=r||o)}return void 0!==s&&(r=this.setOpacity(s)||r),r&&this.updateMaterialCapabilities(),this._material}setRenderingMode(e){this.renderingMode=e,e===c.S.Standard?this.material=this.standardMaterial:this.material=Chunk.modeMaterials[e]}forEachMaterial(e){for(const t in Chunk.chunkMaterials)e(Chunk.chunkMaterials[t])}setProjectedPano(e,t,s,r,i=!1){let a=1===e?"pano1Map":"pano0Map";const o={};o[a]=r||p,t&&(a=1===e?"pano1Position":"pano0Position",o[a]=t),s&&t&&(a=1===e?"pano1Matrix":"pano0Matrix",this.temp.m1.makeRotationFromQuaternion(this.temp.quat.copy(s).invert()),this.temp.m2.makeScale(-1,1,1),o[`${a}1`]=this.temp.m1,o[`${a}2`]=this.temp.m2),this.setMaterialsUniform(o,i)}setOverlayPano(e,t,s,i=!1){const a=`overlay${e}`,o={};if(t){const e=(new r.Matrix4).makeRotationFromQuaternion(t);o[a+"Matrix"]=e}o[a+"Map"]=s||p,this.setMaterialsUniform(o,i)}onBeforeDraw(e){for(const t of Object.keys(e.uniforms))e.uniforms[t].value=this.uniformCache[t].value;e.uniformsNeedUpdate=!0}getSortKey(){var e,t,s;return null!==(s=null===(t=null===(e=this.uniformCache.map)||void 0===e?void 0:e.value)||void 0===t?void 0:t.id)&&void 0!==s?s:0}}Chunk.chunkMaterials={},Chunk.side=r.FrontSide,Chunk.globalUniforms={}},83358:(e,t,s)=>{"use strict";s.d(t,{T:()=>FallbackMesh});var r=s(2212),i=s(48358),a=s(17915);const o=new r.Vector3(0,0,0),n=new r.Vector3(100,100,100),h=new r.Vector3,d=new r.Vector3,u=new r.Box3;class FallbackMesh extends r.Mesh{constructor(){super(),this.bounds=new r.Box3,this.geometry=new r.BoxBufferGeometry(1,1,1),this.geometry.computeBoundingBox(),this.geometry.computeBoundingSphere(),this.chunk=new a.z(-1,-1,this.geometry);const e=e=>{this.material=e};this.chunk.notifyOnMaterialUpdated(e),e(this.chunk.material),this.name="FallbackMesh",this.renderOrder=i.z.boundingSkybox,this.setFromCenterAndSize(o,n),this.onBeforeRender=(e,t,s,i,a,o)=>{a instanceof r.RawShaderMaterial&&this.chunk.onBeforeDraw(a)}}setBounds(e){if(this.bounds.equals(e))return;this.bounds.copy(e);const t=e.getSize(h);this.position.copy(e.getCenter(d)),this.scale.set(t.x,t.y,t.z),this.updateMatrixWorld(!0)}setFromCenterAndSize(e,t=n){this.setBounds(u.setFromCenterAndSize(e,t))}}},62955:(e,t,s)=>{"use strict";s.d(t,{e:()=>ModelMeshBase});var r=s(2212);class ModelMeshBase extends r.Object3D{constructor(){super(...arguments),this.boundingBox=new r.Box3,this.size=new r.Vector3,this.center=new r.Vector3,this._chunks=[]}get chunks(){return this._chunks}get visibleChunks(){return this._chunks}}},32653:(e,t,s)=>{"use strict";s.d(t,{s:()=>RoomMeshData});var r=s(32770);class RoomMeshData extends r.V{constructor(){super(),this.name="room-mesh-data",this.floors=new Set,this.rooms=new Set}}},41659:(e,t,s)=>{"use strict";s.d(t,{u:()=>SetMeshOverlayCommand});var r,i,a=s(17386);!function(e){e.all="all",e.byFloorId="byFloorId",e.byRoomId="byRoomId",e.byMeshGroup="byMeshGroup",e.byMeshSubGroup="byMeshSubGroup"}(r||(r={})),function(e){e.explicit="explicit",e.random="random"}(i||(i={}));class SetMeshOverlayCommand extends a.m{constructor(e,t){super(),this.id="SET_MESH_OVERLAY_COLOR",this.payload={selectBy:(null==t?void 0:t.style)||r.all,colorStyle:(null==e?void 0:e.style)||i.explicit,color:(null==e?void 0:e.color)||null,alpha:(null==e?void 0:e.alpha)||.5,id:null==t?void 0:t.id,index:null==t?void 0:t.index}}}SetMeshOverlayCommand.selectBy=r,SetMeshOverlayCommand.colorBy=i,SetMeshOverlayCommand.COLOR_DIM={x:0,y:0,z:0,w:.3}},51858:(e,t,s)=>{"use strict";s.d(t,{M:()=>SetPanoOverlayCommand});var r=s(17386);class SetPanoOverlayCommand extends r.m{constructor(e,t,s){super(),this.id="SET_PANO_OVERLAY",this.payload={sweepId:e,texture:t,quaternion:s}}}},81638:(e,t,s)=>{"use strict";s.d(t,{I:()=>ToggleMeshOverlayColorCommand});var r=s(17386);class ToggleMeshOverlayColorCommand extends r.m{constructor(e){super(),this.id="TOGGLE_MESH_OVERLAY_COLOR",this.payload={enabled:e}}}},88295:(e,t,s)=>{"use strict";s.r(t),s.d(t,{default:()=>ModelMeshModule});var r=s(47724),i=s(96909),a=s(72067),o=s(17597),n=s(21479),h=s(12216),d=s(59088),u=s(26059),l=s(46114),c=s(44218),m=s(8445),p=s(17399),g=s(32306),f=s(29397),y=s(51764),M=s(85895),x=s(75892),T=s(33512),w=s(64807),v=s(91302),b=s(68576),k=s(88814),S=s(35597),C=s(94329),O=s(79437),B=s(2212),D=s(864);let F=!1;var P=s(81638),R=s(59167),U=s(80301),I=s(67027),G=s(60697),_=s(56247);const z={meshTrimMatrices:[],meshTrimsDiscardContents:[],hasKeepVolume:!1};class MeshTrimUniforms{constructor(e){this.floorUniforms={},this.sharedFloorUniforms={},this.isPanoMode=e}setMeshTrim(e){const{meshGroup:t,index:s,discardContents:r}=e,i=this.getEmptyCacheUniforms(),a=this.getFloorUniforms(t).meshTrimMatrices.slice();this.computeTrimMatrixFromTrim(e,a[s]),i.meshTrimMatrices=a,i.meshTrimsDiscardContents=this.setMeshTrimDiscardContents(t,s,r),this.setFloorUniforms(t,i)}updateMeshTrimArrays(e,t){const s=[],r=[];let i=!1;t.forEach((e=>{s.push(this.computeTrimMatrixFromTrim(e)),r.push(e.discardContents),i||(i=e.enabled&&!e.discardContents)})),this.setFloorUniforms(e,{meshTrimMatrices:s,meshTrimsDiscardContents:r,hasKeepVolume:i});`${e}`==`${G.e}`?Object.keys(this.sharedFloorUniforms).forEach((e=>{this.updateSharedFloorUniforms(e)})):this.updateSharedFloorUniforms(e)}computeTrimMatrixFromTrim(e,t=new B.Matrix4){return e.enabled&&(!this.isPanoMode||this.isPanoMode&&e.activeInPanoMode)?(t.compose(e.position,e.rotation,e.scale),t.invert()):t.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),t}setMeshTrimDiscardContents(e,t,s){const r=this.getFloorUniforms(e).meshTrimsDiscardContents.slice();return r[t]=s,r}updateSharedFloorUniforms(e){const t=this.getFloorUniforms(e),s=this.getFloorUniforms(G.e),r=new B.Matrix4;r.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const i=this.concatUniformArrays(s.meshTrimMatrices,t.meshTrimMatrices,r),a=this.concatUniformArrays(s.meshTrimsDiscardContents,t.meshTrimsDiscardContents,!0);this.setSharedFloorUniforms(e,{meshTrimMatrices:i,meshTrimsDiscardContents:a,hasKeepVolume:s.hasKeepVolume||t.hasKeepVolume})}concatUniformArrays(e,t,s){const r=e.concat(t).slice(0,_.t);for(let e=r.length;e<_.t;e++)r.push(s);return r}getFloorUniforms(e){return this.floorUniforms[`${e}`]||this.getEmptyCacheUniforms()}setFloorUniforms(e,t){this.floorUniforms[`${e}`]=t}getSharedFloorUniforms(e){return this.sharedFloorUniforms[`${e}`]||this.getEmptyCacheUniforms()}setSharedFloorUniforms(e,t){this.sharedFloorUniforms[`${e}`]=t}getEmptyCacheUniforms(){return Object.assign({},z)}}class MeshOverlayColor{constructor(e){this.getChunks=e,this.TOOL_MESH_COLOR_OVERLAY=new B.Vector4(0,0,0,.3),this.enabled=null,this.toggleEnabled=e=>{if(e!==this.enabled){for(const t of this.getChunks())t.setColorOverlay(e?this.TOOL_MESH_COLOR_OVERLAY:null);this.enabled=e}}}}var E=s(10757),A=s(55356),V=s(88512),L=s(33874),Q=s(43993),N=s(2388),q=s(75351),$=s(22377),Z=s(83358),W=s(41659),j=s(91670),Y=s(51858),H=s(17915);const K=new V.Z("modelrenderer");class ModelRenderer{constructor(e,t,s,r,i,a,o,n){this.scene=e,this.container=t,this.mesh=s,this.panoRenderer=r,this.meshData=i,this.sweepData=a,this.applicationData=o,this.renderOptions=n,this.chunkRenderingModeOverride=null,this.lastChunkRenderingModeOverride=null,this.fallbackMesh=new Z.T,this.overlayTextures=[{sweepId:void 0,texture:void 0,renderTarget:new B.WebGLCubeRenderTarget(2048,{format:B.RGBAFormat}),quaternion:new B.Quaternion},{sweepId:void 0,texture:void 0,renderTarget:new B.WebGLCubeRenderTarget(2048,{format:B.RGBAFormat}),quaternion:new B.Quaternion}],this.overlayEnabled=!1,this.bindings=[],this.updateFallbackMesh=(()=>{const e=new B.Box3;return()=>{if(this.sweepData.currentAlignedSweepObject&&this.viewmodeData.isInside()){const t=e.copy(this.meshData.bounds).expandByScalar(.2);this.fallbackMesh.setBounds(t)}else this.cameraData&&this.fallbackMesh.setFromCenterAndSize(this.cameraData.pose.position)}})(),this.debugColorizeChunks=(()=>{let e=!1;return(t,s)=>{const r=new B.Vector4(1,1,1,0);e=!e,(e=>{for(const t of this.mesh.chunks){const i=s?100*t.id:100*t.meshSubgroup,a=e?(0,A.G1)(.5,i):r;t.setColorOverlay(a)}})(t||e)}})()}init(){}dispose(){}async activate(e){this.engine=e,[this.viewmodeData,this.settings,this.cameraData,this.renderer]=await Promise.all([e.market.waitForData(S.O),e.market.waitForData(L.e),e.market.waitForData(d.M_),e.getModuleBySymbol(i.y.WEBGL_RENDERER)]),this.scene.add(this.container),this.scene.add(this.fallbackMesh),this.fallbackMesh.layers.mask=this.container.layers.mask,this.updateRenderState(),this.bindings.push(this.viewmodeData.onChanged(this.updateRenderState.bind(this)),this.sweepData.onChanged(this.updateRenderState.bind(this)),this.settings.onChanged(this.updateRenderState.bind(this)),e.commandBinder.addBinding(W.u,this.onMeshOverlayCommand.bind(this)),e.commandBinder.addBinding(j.U,this.onSetChunkRenderStateCommand.bind(this)),e.commandBinder.addBinding(Y.M,this.onPanoOverlayCommand.bind(this))),this.renderOptions.colorizeRooms&&this.debugColorizeChunks(!0),this.renderOptions.colorizeChunks&&this.debugColorizeChunks(!0,!0),this.renderOptions.wireframe&&this.toggleWireframe(!0),this.setupDebugMenu(e)}deactivate(){for(const e of this.bindings)e.cancel();this.bindings=[],this.scene.remove(this.container),this.scene.remove(this.fallbackMesh),this.currentSweepId&&this.panoRenderer.freeTexture(this.currentSweepId),this.currentSweepId=null,this.targetSweepId=null}updateSweepRenderTarget(e,t,s,r){const i=this.panoRenderer.useTexture(t);if(i){let t=!0;for(const a of this.allChunks())a.setProjectedPano(e,s,r,i,t),t=!1}}*allChunks(){yield*this.mesh.chunks,yield this.fallbackMesh.chunk}updateExistingTexture(e,t,s,r){let i=!0;for(const a of this.allChunks())e===this.currentSweepId&&a.setProjectedPano(0,s,r,t,i),e===this.targetSweepId&&a.setProjectedPano(1,s,r,t,i),i=!1}render(){}beforeRender(){var e;const t=!this.displayingUnaligned(this.sweepData,this.viewmodeData);this.container.visible=t;const{floorOpacity:s,floorFadeDist:r}=this.meshData.meshGroupVisuals;for(const t of this.mesh.visibleChunks)t.setMaterialsUniform({meshOpacity:this.meshData.meshTextureOpacity.value,panoOpacity:1-this.meshData.meshTextureOpacity.value,opacity:null!==(e=s.get(t.meshGroup))&&void 0!==e?e:1,transparentDiscardDist:r.get(t.meshGroup)||0,progress:this.sweepData.transition.progress.value});const i=(0,O.w2)(this.meshData.meshTextureOpacity.value,0,1,1);this.fallbackMesh.chunk.setMeshTextureOpacity(i),this.fallbackMesh.chunk.setProgress(this.sweepData.transition.progress.value),this.updateFallbackMesh()}displayingUnaligned(e,t){return t.closestMode===C.Ey.Panorama&&!!e.currentSweep&&e.isSweepUnaligned(e.currentSweep)}updateChunkMaterialMode(e,t){const s=t||q.S.Standard,r=e?B.DoubleSide:B.FrontSide;H.z.setSide(r);for(const e of this.mesh.chunks)e.setRenderingMode(s)}updateRenderState(){if(this.container.visible=this.settings.tryGetProperty(N.AN,!0),this.viewmodeData.currentMode!==this.lastViewmode||this.lastChunkRenderingModeOverride!==this.chunkRenderingModeOverride){this.lastChunkRenderingModeOverride=this.chunkRenderingModeOverride;const e=this.viewmodeData.isInside();this.updateChunkMaterialMode(e,this.chunkRenderingModeOverride),this.lastViewmode=this.viewmodeData.currentMode}if(this.viewmodeData.transition.active&&(0,C.Bw)(this.viewmodeData.transition.to)||this.viewmodeData.isInside()){const e=this.sweepData.currentSweep,t=this.sweepData.transition,s=t.active&&(this.applicationData.phase===n.nh.PLAYING||this.applicationData.phase===n.nh.STARTING),r=s?t.from:e,i=s?t.to:e,a=this.currentSweepId,o=this.targetSweepId;this.currentSweepId=r||null,this.targetSweepId=i||null,this.handleSweepChange(0,a,this.currentSweepId),this.handleSweepChange(1,o,this.targetSweepId)}if(this.overlayEnabled){const e=this.overlayTextures.find((e=>e.sweepId===this.currentSweepId)),t=this.overlayTextures.find((e=>e.sweepId===this.targetSweepId));let s=!0;for(const r of this.allChunks())r.setOverlayPano(0,e?e.quaternion:void 0,e?e.texture:void 0,s),r.setOverlayPano(1,t?t.quaternion:void 0,t?t.texture:void 0,s),s=!1}}handleSweepChange(e,t,s){if(t!==s&&(t&&this.panoRenderer.freeTexture(t),s)){const t=this.sweepData.getSweep(s);this.updateSweepRenderTarget(e,s,t.position,t.rotation)}}async onPanoOverlayCommand(e){this.overlayEnabled=!0;const t=t=>{const s=t.renderTarget;t.renderTarget.width=e.texture.image.width,t.renderTarget.height=e.texture.image.height,t.sweepId=e.sweepId,t.texture=s.texture,t.quaternion=e.quaternion,this.renderer.cwfRenderer.copyCubemap(e.texture,t.renderTarget)};let s=!1;for(const r of this.overlayTextures)s||r.sweepId!==e.sweepId||(t(r),s=!0);for(const e of this.overlayTextures)s||e.sweepId===this.targetSweepId||e.sweepId===this.currentSweepId||(t(e),s=!0);this.updateRenderState()}async onMeshOverlayCommand(e){const t=this.meshData.meshGroups.rooms,s=this.meshData.meshGroups.roomIds,r=this.meshData.meshGroups.floors,i=this.meshData.meshGroups.floorIds;let a;switch(e.selectBy){case W.u.selectBy.all:a=()=>!0;break;case W.u.selectBy.byFloorId:a=t=>{let s=!1;for(const a of r)t.meshGroup===a.meshGroup&&i[t.meshGroup]===e.id&&(s=!0);return s};break;case W.u.selectBy.byRoomId:a=r=>{let i=!1;for(const{meshSubgroup:a,meshGroup:o}of t)r.meshSubgroup===a&&r.meshGroup===o&&s.get(r.meshGroup,r.meshSubgroup)===e.id&&(i=!0);return i};break;case W.u.selectBy.byMeshGroup:a=t=>t.meshGroup===e.index;break;case W.u.selectBy.byMeshSubGroup:a=t=>t.meshSubgroup===e.index}if(!a)return;let o="rand";e.colorStyle===W.u.colorBy.explicit&&(o=e.color?new B.Vector4(e.color.x,e.color.y,e.color.z,e.color.w):null);for(const t of this.mesh.chunks)a(t)&&t.setColorOverlay("rand"===o?(0,A.G1)(e.alpha):o)}async onSetChunkRenderStateCommand(e){this.chunkRenderingModeOverride=e.mode,this.updateRenderState()}toggleWireframe(e){for(const t of this.mesh.chunks)t.setWireframe(e)}async setupDebugMenu(e){const[t,s]=await Promise.all([e.market.waitForData(L.e),e.getModule(Q.default)]);s.registerButton("Mesh","Toggle visible",(()=>{this.container.visible=!this.container.visible})),s.registerButton("Mesh","Toggle depth",(()=>{const t=this.chunkRenderingModeOverride?null:q.S.Depth;e.commandBinder.issueCommand(new j.U(t))})),s.registerButton("Mesh","Toggle transparent",(()=>{const t=this.chunkRenderingModeOverride?null:q.S.Transparent;e.commandBinder.issueCommand(new j.U(t))})),s.registerButton("Mesh","Toggle wireframe",(()=>{const t=this.chunkRenderingModeOverride?null:q.S.Wireframe;e.commandBinder.issueCommand(new j.U(t))}));let r=!1;s.registerButton("Mesh","Toggle flat shading",(()=>{r=!r;for(const e of this.mesh.chunks)e.setFlatShading(r)})),s.registerButton("Mesh","Cycle all chunk materials",(()=>{this.debugCycleChunkMaterials()})),s.registerButton("Mesh","Highlight Rooms",this.debugColorizeChunks),s.registerButton("Mesh","Highlight Chunks",(()=>this.debugColorizeChunks(!0,!0)));const i=(e,r,i,a,o)=>{s.registerSetting(e,r,i,!0,Q.SettingPersistence.NONE,o),t.onPropertyChanged(r,a)};i("Wireframe",N.Lp,!1,this.toggleWireframe.bind(this));const a={[$.h.Wireframe]:{Wireframe:["thickness","wireframeOpacity","stroke","fillEnabled","fill","insideAltColor","dualStroke","secondThickness"],"Wireframe Dashes":["dashEnabled","dashLength","dashAnimate","dashOverlap"],"Wireframe Advanced":["squeeze","squeezeMin","squeezeMax"]}};for(const e in a){const t=_.Z.modelChunk.uniforms[e];for(const s in a[e])for(const r of a[e][s])i(s,r,t[r].value,(e=>{for(const t of this.mesh.chunks)t.setMaterialsUniform({[r]:e})}),t[r].range)}}async debugCycleChunkMaterials(){const e=[];for(const t in $.h)isNaN(Number(t))&&e.push($.h[t]);const t=[];for(const e in q.S)isNaN(Number(e))&&t.push(q.S[e]);K.info(`Available ChunkMaterialCapabilities: ${e}`);const s=[];for(let t=0;t<1<<e.length-1;t++){const r={};for(let s=e.length-1;s>=0;s--){r[e[s]]=Boolean(t&1<<s)}s.push(r)}K.info(`There are ${s.length*t.length} options to test`);for(let e=0;e<t.length;e++){await this.engine.commandBinder.issueCommand(new j.U(e));for(const t of s){K.info(`Testing ChunkRenderingMode.${q.S[e]} with capabilities: ${JSON.stringify(t,void 0,2)}`);const s=new B.Vector4(Math.random(),Math.random(),Math.random(),.5);for(const e of Object.keys(t))for(const r of this.mesh.chunks)r.setColorOverlay(s),r.setMeshPreviewSphere(new B.Vector3(0,0,0)),r.overrideCapability(e,t[e]);await(0,E.gw)(100)}await(0,E.gw)(100)}await this.engine.commandBinder.issueCommand(new j.U(null))}}var X=s(20331),J=s(6559);class MeshRenderPass{constructor(e,t,s=128,r=128){this.slots=e,this.renderToTextureModule=t,this.width=s,this.height=r,this.sizeMultiplier=1/8,this.pixelBuffer=new Uint8Array(4),this.readBuffer=null,this.readPixelsAsync=Promise.resolve(this.pixelBuffer)}get renderTarget(){return this._renderTarget||(this._renderTarget=new B.WebGLRenderTarget(this.width,this.height,{type:B.UnsignedByteType,format:B.RGBAFormat,depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,minFilter:B.NearestFilter,magFilter:B.NearestFilter})),this._renderTarget}pixels(){return this.pixelBuffer}renderAndReadAsync(e,t){this.beforeRender(),this.updateReadBufferSize(),this.readPixelsAsync=this.renderToTextureModule.renderAndReadAsync({mesh:e,camera:t,target:this.renderTarget,clear:!0},{x:0,y:0,width:this.width,height:this.height},{buffer:this.pixelBuffer}).then((e=>(this.pixelBuffer=e,this.pixelBuffer))),this.afterRender()}render(e,t,s=!1,r=!0){this.beforeRender();let{width:i,height:a}=this.renderToTextureModule.getRenderSize();i=Math.max(1,Math.floor(i*this.sizeMultiplier)),a=Math.max(1,Math.floor(a*this.sizeMultiplier)),i===this.renderTarget.width&&a===this.renderTarget.height||this.renderTarget.setSize(i,a),this.renderToTextureModule.render(this.renderTarget,e,t),s&&this.renderToScreen(),r&&this.afterRender()}renderToScreen(){this.renderToTextureModule.renderToScreen(this.renderTarget,!1)}readPixels(){this.updateReadBufferSize();const e=this.pixelBuffer;return this.pixelBuffer=this.renderToTextureModule.getRenderTargetData(this.renderTarget,e),this.pixelBuffer}updateReadBufferSize(){const e=this.renderTarget.width*this.renderTarget.height*4;this.pixelBuffer.length!==e&&(this.pixelBuffer=new Uint8Array(e))}beforeRender(){this.width===this.renderTarget.width&&this.height===this.renderTarget.height||this.renderTarget.setSize(this.width,this.height);for(const e of this.slots)for(const t of e.chunks)this.beforeRenderChunk(t,e)}afterRender(){for(const e of this.slots)for(const t of e.chunks)this.afterRenderChunk(t,e)}}class TextureQualityRenderPass extends MeshRenderPass{constructor(){super(...arguments),this.prevColor=new WeakMap}beforeRenderChunk(e,t){this.prevColor.set(t,e.getColorOverlay()),e.setColorOverlay((0,J.O7)(t.quality))}afterRenderChunk(e,t){var s;e.setColorOverlay(null!==(s=this.prevColor.get(t))&&void 0!==s?s:null)}}class TextureScoreRenderPass extends MeshRenderPass{constructor(){super(...arguments),this.prevColor=new WeakMap}beforeRender(){this.maxValue=this.slots.reduce(((e,t)=>Math.max(e,t.screenCoverageScore)),1e-9),super.beforeRender()}beforeRenderChunk(e,t){const s=t.screenCoverageScore/this.maxValue,r=new B.Vector4(s,s,s,1);this.prevColor.set(t,e.getColorOverlay()),e.setColorOverlay(r)}afterRenderChunk(e,t){var s;e.setColorOverlay(null!==(s=this.prevColor.get(t))&&void 0!==s?s:null)}}var ee=s(58232),te=s(17916);class MeshTextureSlot{constructor(e,t=te.V.Standard,s){this.lod=t,this.chunkedTexInfo=s,this.chunks=new Set,this.loading=!1,this.unloaded=!1,this.screenCoverage=0,this.screenCoverageScore=0,this.sightings=new ee.P(N.ZP.sightingMaxAge),this.textureName=e,this.lod=t,s&&((0,J.qT)().registerQualities(t,s.maxTextureSize,s.maxTexelSize,s.minScale),this.quality=(0,J.qT)().min(t),this.targetQuality=this.quality),this.minQuality=(0,J.qT)().min(t),this.maxQuality=this.minQuality}setTexture(e){if(this.texture&&this.texture!==e&&this.texture.dispose(),this.texture=e,this.texture)for(const e of this.chunks)e.setMeshTexture(this.texture)}async getUrl(e){const t=(0,J.qT)().get(e),{assetType:s}=t;if(this.textureData){let e=this.textureName;if(!this.chunkedTexInfo){const t=this.textureName.match(/[_.]([0-9]{3})[_.]/);if(!t)throw new Error(`Could not parse texture index from texture name: ${this.textureName}`);e=t[1]}return(await this.textureData[s].get()).urlTemplate.replace("<texture>",e)}{const e=this.textureName.match(/^([a-f0-9]+(_10k|_50k)?)/);if(!e)throw new Error(`Unknown format for texture name: ${this.textureName}`);return`${e[0]}_texture_jpg_${s}/${this.textureName}`}}}var se=s(60771),re=s(59855);class TextureBudgeter{constructor(){this.lods=new Map,this.orders={}}updateBudgetForStyle(e){this.slots=e;const t=(0,J.qT)();e.forEach((e=>{const s=this.lods.get(e.lod)||new Set;s.add(e),this.lods.set(e.lod,s),this.orders[e.lod]=t.order(e.lod)})),this.baseSizeUnit=t.minSize().textureSize;let s=0;for(const[e,r]of this.lods.entries())s+=r.size*this.getBudgetSize(t.max(e));return this.minBudget=this.slots.reduce(((e,t)=>e+this.getBudgetSize(t.minQuality)),0),this.maxBudget=this.restrictBudget()?this.minBudget+re.t.fixedMobileBudget:s,this._budget=this.minBudget,this}update(e){this.budget=this.maxBudget}getBudgetSize(e){return e?((0,J.qT)().get(e).textureSize/this.baseSizeUnit)**2:0}calcCurrentUsedBudget(){return this.slots.reduce(((e,t)=>e+this.getBudgetSize(t.quality)),0)}clampBudget(e){return Math.min(this.maxBudget,Math.max(this.minBudget,e))}restrictBudget(){return(0,se.tq)()&&(0,J.qT)().isDynamic}get budget(){return this._budget}set budget(e){e=this.clampBudget(e),this.budget!==e&&(this._budget=e,this.updateTargetQualitiesFromBudget())}updateTargetQualitiesFromBudget(){let e=0;for(const t of this.slots)t.targetQuality=t.minQuality,e+=this.getBudgetSize(t.targetQuality);const t=(t,s)=>t.maxQuality<s||(e-=this.getBudgetSize(t.targetQuality),e+=this.getBudgetSize(s),!(e>this.budget)&&(t.targetQuality=s,!0));if(this.restrictBudget()){for(const e of this.slots)for(const s of this.orders[e.lod])if(!t(e,s))return}else for(const[e,s]of this.lods.entries())for(const r of this.orders[e])for(const e of s)if(!t(e,r))return}}var ie=s(69626),ae=s(27408),oe=s(67502),ne=s(84303);const he=new V.Z("tex-lod");class MeshTextureLoader{constructor(e,t,s,r,i,a,o,n,h){this.textureLOD=e,this.urls=t,this.modelObject=s,this.camera=r,this.cameraData=i,this.renderer=a,this.renderToTextureModule=o,this.engine=n,this.chunkVisibilityChecker=h,this.name="texture-streaming",this.slots=[],this.textureNameToSlot={},this.chunkIdToSlot={},this._systemMin=J.S7.LOW,this._systemMax=J.S7.ULTRA,this.allowTextureDownload=()=>!0,this.concurrentLoadingTextures=1,this.concurrentDownloadingTiles=12,this.autoLoadTiles=!1,this.lastSortedAt=0,this.loadingTextures=0,this.downloadingTiles=0,this.totalTextures={},this.totalTiles=0,this.textureQualityRenderPass=new TextureQualityRenderPass(this.slots,this.renderToTextureModule),this.textureScoreRenderPass=new TextureScoreRenderPass(this.slots,this.renderToTextureModule),this._chunkSlotsSet=new Set}setModel(e,t,s){this.textureApiInfo=s,this.modelObject=e,this.slots.length=0,this.textureNameToSlot={},this.chunkIdToSlot={},this.addChunkSlots([...t]),this.textureBudgeter=(new TextureBudgeter).updateBudgetForStyle(this.slots),this.updateSystemQualityRanges(),this.chunkVisibilityChecker.notifyOnNewSighting(((e,t)=>{const s=this.addChunkSlots([e]);for(const e of s)e.sightings.push(t)}))}addChunkSlots(e){this._chunkSlotsSet.clear();let t=!1;for(const s of e){const e=s.textureName;let r=this.textureNameToSlot[e];r||(t=!0,r=new MeshTextureSlot(e,s.lod,s.textureLODInfo),this.textureApiInfo&&(r.textureData=this.textureApiInfo),this.textureNameToSlot[s.textureName]=r,this.slots.push(r)),r.chunks.has(s)||(t=!0,r.chunks.add(s)),this._chunkSlotsSet.add(r),this.chunkIdToSlot[s.id]=r}return t&&this.textureBudgeter&&(this.textureBudgeter.updateBudgetForStyle(this.slots),this.updateSystemQualityRanges()),this._chunkSlotsSet}removeChunks(e){for(const t of e){const e=this.chunkIdToSlot[t.id];if(e){if(e.chunks.delete(t),e.unloaded=!0,0===e.chunks.size){e.setTexture(null);const s=this.slots.indexOf(e);this.slots.splice(s,1),delete this.textureNameToSlot[t.textureName]}delete this.chunkIdToSlot[t.id]}else he.error("Missing slot for chunk!")}}setQuality(e,t){this._systemMin=e,this._systemMax=t,this.updateSystemQualityRanges()}updateSystemQualityRanges(){const e=(0,J.qT)();this.minQuality={},this.maxQuality={};for(const t of new Set([...this.slots.map((e=>e.lod))]).values())this.minQuality[t]=e.nearestQuality(t,this._systemMin),this.maxQuality[t]=e.nearestQuality(t,this._systemMax);for(const e of this.slots)e.minQuality=this.minQuality[e.lod],e.maxQuality=e.maxQuality?Math.min(this.maxQuality[e.lod],e.maxQuality):this.maxQuality[e.lod]}get textureCount(){return this.slots.length}loadAll(e){if(!this.slots[0]||!this.slots[0].textureName)return Promise.resolve([]);const t=(0,J.qT)();if(!t.valid(e))return he.warn(e,"not found in",t),Promise.resolve([]);const s=this.slots.map((t=>this.loadTexture(t,e,!1)));return Promise.all(s)}async loadTexture(e,t,s=!0){var r;const i=(0,J.qT)();i.valid(t)||he.warn(t,"not found in",i);const a=i.get(t),o=(null===(r=e.chunkedTexInfo)||void 0===r?void 0:r.maxTextureSize)||a.assetSize,n=Math.min(o,a.textureSize);e.lastLoadedAt=performance.now();let h=e.texture;if(h&&t===e.quality&&e.texture)return e.texture;if(h&&t<e.quality&&e.texture){const s=e.chunks.values().next().value;if(s&&s.embeddedTexture&&s.textureSizeEmbedded>=n&&s.embeddedTexture.mipmaps[0].data.length<=n*n*3)return e.quality=t,e.setTexture(s.embeddedTexture),e.texture;{const s=this.renderToTextureModule.resizeTexture(h,n);return e.quality=t,e.setTexture(s),e.texture}}h=new B.Texture,h.format=B.RGBFormat,this.renderer.initSizedTexture2D(n,h),e.loading=!0,this.loadingTextures++,this.totalTextures[n]=(this.totalTextures[n]||0)+1;try{h.sourceFile=await e.getUrl(t),this.textureLOD!==U.l.NONE&&s?await this.updateTextureTiled(h,t,e):await this.updateTextureSolid(h,t),e.unloaded?h.dispose():e.setTexture(h)}catch(e){h.dispose()}finally{this.loadingTextures--,e.quality=t,e.loading=!1}return h}async updateTextureTiled(e,t,s){var r;e.generateMipmaps=!1,e.minFilter=B.LinearFilter,e.magFilter=B.LinearFilter;const i=(0,J.qT)(),a=(null===(r=s.chunkedTexInfo)||void 0===r?void 0:r.maxTextureSize)||i.get(t).assetSize,o=Math.min(a,i.get(t).textureSize),n=Math.min(o,i.get(t).tileSize),h=a/(o/n),d=async(t,s)=>{const r={};let i;h!==n&&(r.width=`${n}`),h!==a&&(r.crop=`${h},${h},x${t/o},y${s/o}`),this.downloadingTiles+=1,this.totalTiles+=1;const d=N.ZP.flipDownload;try{i=await this.urls.getImageBitmap(e.sourceFile,n,n,{priority:X.RequestPriority.LOW,flipY:d},r)}finally{this.downloadingTiles-=1}const u=t,l=N.ZP.flipUpload?o-s-n:s,c=new oe._("mesh/texture/upload-tiles",(()=>this.engine.after(ne.A.End).then((()=>{var t,s;e.flipY=d&&i instanceof HTMLImageElement,this.renderer.uploadTexture2D(i,e,u,l),null===(s=(t=i).close)||void 0===s||s.call(t)}))),100);return(await this.engine.commandBinder.issueCommand(c)).promise},u=[];for(let e=0;e<o;e+=n)for(let t=0;t<o;t+=n)u.push(d(e,t));return Promise.all(u)}async updateTextureSolid(e,t){var s,r;const i=(0,J.qT)().get(t).textureSize,a=N.ZP.flipDownload,o=await this.urls.getImageBitmap(e.sourceFile,i,i,{priority:X.RequestPriority.LOW,flipY:a},{width:`${i}`});e.flipY=a&&o instanceof HTMLImageElement,this.renderer.uploadTexture2D(o,e,0,0),null===(r=(s=o).close)||void 0===r||r.call(s)}analyzeTextureScreenCoverageFromRaycasts(){const e=window.innerWidth,t=(new B.Vector3).copy(this.cameraData.pose.position),s=(0,J.qT)();for(const r of this.slots){r.screenCoverage=0,r.screenCoverageScore=0,r.maxQuality=r.minQuality;const i=r.sightings.getList(),a=r.sightings.index-1;for(let o=0;o<i.length;o++){const n=i[(a-o+i.length)%i.length];if(n.raycastAge<this.chunkVisibilityChecker.raycastCounter-N.ZP.sightingMaxAge)break;const h=t.distanceTo(n.point),d=(0,ie._U)(h,this.camera.projectionMatrix,e);let u=s.fromPixelSize(r.lod,d);u=Math.min(u,this.maxQuality[r.lod]),r.screenCoverageScore+=u,r.screenCoverage+=1,r.maxQuality=Math.max(u,r.maxQuality)}}this.slots.sort(((e,t)=>t.screenCoverageScore-e.screenCoverageScore)),this.textureBudgeter.updateTargetQualitiesFromBudget()}update(e){if(this.textureBudgeter.update(e),!this.camera||!this.autoLoadTiles)return;const t=performance.now();this.textureLOD===U.l.RAYCAST&&this.scheduleRaycastTasks(t);for(let e=this.slots.length-1;e>=0;e--){const s=this.slots[e],r=(0,ae.uZ)(s.targetQuality,s.minQuality,s.maxQuality),i=t-s.lastLoadedAt<1e3;if(!s.loading&&s.quality>r&&!i){this.loadTexture(s,r);break}}if(this.allowTextureDownload()){const e=(0,J.qT)();for(const t of this.slots){if(this.loadingTextures>=this.concurrentLoadingTextures||this.downloadingTiles>=this.concurrentDownloadingTiles)break;const s=(0,ae.uZ)(t.targetQuality,t.minQuality,t.maxQuality);!t.loading&&t.quality<s&&this.loadTexture(t,e.moreDetailed(t.lod,t.quality))}}N.ZP.debugRttScores&&this.textureScoreRenderPass.render(this.modelObject,this.camera,!0,N.ZP.debugRttClear),N.ZP.debugRttQuality&&this.textureQualityRenderPass.render(this.modelObject,this.camera,!0,N.ZP.debugRttClear)}scheduleRaycastTasks(e){if(!this.analyzeTaskPromise&&e-this.lastSortedAt>200){const e=()=>{this.analyzeTextureScreenCoverageFromRaycasts(),this.lastSortedAt=performance.now()},t=async e=>{await e.promise,this.analyzeTaskPromise=null},s=new oe._("mesh/texture/analyze-screen-coverage",e,100);this.analyzeTaskPromise=this.engine.commandBinder.issueCommand(s).then(t)}}}var de=s(32653),ue=s(76863),le=s(21922),ce=s(86980),me=s(44283);const pe=Math.round(N.ZP.sightingMaxAge/60/5)||1;class ChunkVisibilityChecker{constructor(e,t,s){this.scene=e,this.raycaster=t,this.raycastCounter=0,this.onNewSighting=new Set,this.poseSetAt=0,this.raycastRandomScreenLocation=(()=>{const e=new B.Vector3,t=new B.Vector3,s=new B.Vector3;return(r,i,a)=>{this.raycastCounter++;const o=(2-2*i)/r,n=-1+i,h=this.raycastCounter%(r*r),d=h%r,u=n+(h-d)/r*o,l=n+d*o+Math.random()*o,c=u+Math.random()*o;e.set(l,c,-1).unproject(this.camera),t.set(l,c,1).unproject(this.camera),s.subVectors(t,e).normalize();const m=this.raycaster.pick(e,s,ue.Pv);if(m){if(m.face&&m.object instanceof le.g){const e=m.object.getChunk(m.face.materialIndex),t={point:m.point.clone(),raycastAge:this.raycastCounter};for(const s of this.onNewSighting.values())s(e,t)}a&&a(m)}}})(),this.camera=e.camera,s.pose.onChanged((()=>{this.poseSetAt=this.raycastCounter}))}update(){const e=N.ZP.debugLOD?(0,ce.e)(65280,this.scene):void 0,t=performance.now();for(let s=0;s<pe&&performance.now()-t<.5&&this.raycastCounter<=this.poseSetAt+N.ZP.sightingMaxAge;s++)this.raycastRandomScreenLocation(5,.05,e)}notifyOnNewSighting(e){return(0,me.k1)((()=>this.onNewSighting.add(e)),(()=>this.onNewSighting.delete(e)),!0)}}class ModelMeshModule extends r.Y{constructor(){super(...arguments),this.name="model-mesh",this.colorOverlay=null,this.toggleMeshOverlayColor=e=>{this.colorOverlay||(this.colorOverlay=new MeshOverlayColor((()=>this.modelMesh.chunks))),this.colorOverlay.toggleEnabled(e)},this.onMeshTrimGroupChanged=e=>{this.setTrimsForMeshGroup(e)},this.updateTrimVisibilityForViewmode=e=>{if(e!==this.meshTrimUniforms.isPanoMode){this.meshTrimUniforms.isPanoMode=e;for(const e of this.meshTrimData.meshTrimsByMeshGroup.keys)this.setTrimsForMeshGroup(e)}},this.updateMeshTrim=e=>{this.meshTrimUniforms.setMeshTrim(e),this.setTrimsForMeshGroup(e.meshGroup)},this.updateMaxQuality=(()=>{let e,t,s;return({modeChange:r,criticalChange:i,interactionChange:a})=>{void 0!==i&&(t=i),void 0!==r&&(e=r),void 0!==a&&(s=a);const o=s===u.s.VrOrientOnly||s===u.s.VrWithController||s===u.s.VrWithTrackedController,n=J.S7.LOW,h=Math.max(n,e===C.Ey.Panorama&&0===this.meshData.meshTextureOpacity.value?n:this.config.maxQuality);this.modelMesh.setTextureQuality(this.modelTextureLoader,n,h);const d=this.viewmodeData.currentMode!==C.Ey.Dollhouse&&this.viewmodeData.currentMode!==C.Ey.Floorplan,l=this.viewmodeData.transition.active&&(0,C.Bw)(this.viewmodeData.transition.to);this.modelTextureLoader.autoLoadTiles=!(o||l||t&&d)&&this.config.textureLOD!==U.l.NONE}})()}async init(e,t){F||(B.Mesh.prototype.raycast=D.uL,B.BufferGeometry.prototype.computeBoundsTree=D.Xy,B.BufferGeometry.prototype.disposeBoundsTree=D.sn,F=!0),this.config=e,this.engine=t,this.market=t.market;const[r,h,u,l,f,y,M,T,v,b]=await Promise.all([t.getModuleBySymbol(i.y.WEBGL_RENDERER),t.getModule(p.default),t.getModule(c.default),t.market.waitForData(m.T),t.getModuleBySymbol(i.y.INPUT),t.getModule(g.default),t.market.waitForData(d.M_),t.market.waitForData(S.O),t.market.waitForData(x.Z),t.getModuleBySymbol(i.y.SWEEP_PANO)]),k=await t.getModule(Q.default);this.appData=await t.market.waitForData(n.pu),this.sweepData=v,this.viewmodeData=T;const C=r.getScene(),O=u.getSignedUrls(),I=l.model,G=I.uuid,_=t.claimRenderLayer(this.name);this.panoRenderer=b.getRenderer();const z=new de.s;H.z.setMaxVaryings(r.maxVaryings),this.chunkVisibiltyChecker=new ChunkVisibilityChecker(C,h.picking,M);const E=I.tileset&&k.tryGetProperty(N.iT,!1)?await Promise.all([s.e(47),s.e(670),s.e(38),s.e(983)]).then(s.bind(s,98130)):await Promise.all([s.e(947),s.e(321)]).then(s.bind(s,51344));this.modelMesh=await E.createModelMesh({uuid:G,urls:O,renderLayer:_,engine:t,settings:N.ZP,modelData:l,roomMeshData:z,chunkFactory:(e,t,s,r)=>new H.z(e,t,s,r,!0),chunkVisibilityChecker:this.chunkVisibiltyChecker}),this.engine.market.register(this,de.s,z);let A=Promise.resolve();const V=this.modelMesh;this.setupMarketData(V.chunks,v),e.renderMeshGeometry&&(this.modelTextureLoader=new MeshTextureLoader(e.textureLOD,O,this.modelMesh,C.camera,M,r.cwfRenderer,y,t,this.chunkVisibiltyChecker),this.modelTextureLoader.autoLoadTiles=e.textureLOD!==U.l.NONE,A=this.modelMesh.initTextureLoader(this.modelTextureLoader,l.model,(()=>{this.updateMaxQuality({})}),{streamingTextures:e.textureLOD!==U.l.NONE,maxQuality:e.maxQuality}),this.bindAppEventsToTextureQuality()),h.setupOctree(this.modelMesh.boundingBox),this.modelMesh.registerCollision(f),e.renderMeshGeometry&&(this.renderer=new ModelRenderer(C.scene,this.modelMesh,this.modelMesh,this.panoRenderer,this.meshData,this.sweepData,this.appData,e),await t.addComponent(this,this.renderer),await A),this.bindings.push(this.engine.subscribe(w.Z,(e=>{this.renderer.updateExistingTexture(e.sweepId,e.renderTarget.texture)}))),this.bindings.push(t.commandBinder.addBinding(P.I,(async e=>this.toggleMeshOverlayColor(e.enabled))),t.commandBinder.addBinding(R.n,this.setPreviewPosition.bind(this))),e.meshTrimEnabled?await this.bindMeshTrimListeners():this.bindMeshTrimListeners(),(0,o.eY)("debug","")&&a.Z.load(a.Z.menus.StreamingTexture,t)}onUpdate(e){this.modelMesh.onUpdate(),this.modelTextureLoader&&!N.ZP.debugPauseTexStream&&this.modelTextureLoader.update(e),this.chunkVisibiltyChecker&&this.chunkVisibiltyChecker.update(),this.meshData.meshTextureOpacity.active&&(this.meshData.meshTextureOpacity.updateProgress(this.viewmodeData.transition.progress),this.meshData.commit());const t=performance.now()/1e3;for(const e of this.modelMesh.chunks)e.setTime(t)}setupMarketData(e,t){const s=new Map,r=new Map,i=new B.Box3;e.forEach((e=>{e.geometry.boundingBox&&i.union(e.geometry.boundingBox),s.set(e.meshGroup,(s.get(e.meshGroup)||[]).concat(e)),r.set(e.meshSubgroup,(r.get(e.meshSubgroup)||[]).concat(e))}));const a=new B.Box3;t.iterate((e=>{e.isUnplaced()||(a.setFromCenterAndSize(e.position,h.f.UNIT),i.union(a))}));const o=new I._(0,[...i.min.toArray(),...i.max.toArray()]);for(const[e,t]of s.entries()){const s=new B.Box3;t.forEach((e=>{e.geometry.boundingBox&&s.union(e.geometry.boundingBox)})),o.meshGroups.floors.add({meshGroup:e,boundingBox:s,parentMeshGroup:null});const i=[...new Set(t.map((e=>e.meshSubgroup)))].sort(((e,t)=>t-e)).map((t=>({meshGroup:e,meshSubgroup:t})));o.meshGroups.roomsByFloor.set(e,i);for(const t of i){const{meshSubgroup:s}=t,i=new B.Box3;(r.get(s)||[]).forEach((e=>{e.geometry.boundingBox&&i.union(e.geometry.boundingBox)}));const a={meshGroup:s,boundingBox:i,parentMeshGroup:e};o.meshGroups.rooms.get(e,s)&&this.log.warn("Duplicate room meshSubgroup found in model - \nold:",o.meshGroups.rooms.get(e,s),"\nnew:",a),o.meshGroups.rooms.set(e,s,a)}o.meshGroupVisuals.floorOpacity.set(e,1),o.meshGroupVisuals.floorFadeDist.set(e,0)}this.meshData=o,this.meshData.onMeshIdsUpdated(this.onMeshIdsUpdated.bind(this)),this.market.register(this,I._,this.meshData)}onMeshIdsUpdated(){const e=this.meshData.meshGroups;Object.keys(e.floorIds).length&&Object.keys(e.roomIds).length&&this.modelMesh.onMeshIdsUpdated(this.meshData.meshGroups)}startOpacityTransition(){const e=this.viewmodeData.transition.to,t=this.meshData.meshTextureOpacity.value,s=e===C.Ey.Panorama?0:1,r=e===C.Ey.Panorama?O.Q9:O.w2;this.meshData.meshTextureOpacity.value!==s&&this.meshData.meshTextureOpacity.modifyAnimation(t,s,1,r)}setMeshOpacity(e){e!==this.meshData.meshTextureOpacity.value&&(this.meshData.meshTextureOpacity.modifyAnimation(e,e,0),this.meshData.commit())}async bindMeshTrimListeners(){this.meshTrimData=await this.engine.market.waitForData(T.Z),this.meshTrimUniforms=new MeshTrimUniforms(this.viewmodeData.isPano());const{meshTrimsByMeshGroup:e}=this.meshTrimData;this.meshTrimData.onMeshGroupChanged(this.onMeshTrimGroupChanged),this.meshTrimData.onMeshTrimChanged(this.updateMeshTrim),this.bindings.push(this.engine.subscribe(b.Z,(e=>{e.fromMode===C.Ey.Panorama&&this.updateTrimVisibilityForViewmode(e.toMode===C.Ey.Panorama)})),this.engine.subscribe(k.Z,(e=>{this.updateTrimVisibilityForViewmode(e.toMode===C.Ey.Panorama)}))),e.keys.forEach((e=>{this.setTrimsForMeshGroup(e)})),this.setMaterialsUniforms(G.e)}setTrimsForMeshGroup(e){const t=this.meshTrimData.getTrimsForMeshGroup(e);this.meshTrimUniforms.updateMeshTrimArrays(e,t),this.setMaterialsUniforms(e)}setMaterialsUniforms(e){const t=`${e}`;if(t===`${G.e}`)this.modelMesh.chunks.forEach((e=>{const t=this.meshTrimUniforms.getSharedFloorUniforms(e.meshGroup);e.setMaterialsUniform(t)}));else{const s=this.meshTrimUniforms.getSharedFloorUniforms(e);this.modelMesh.chunks.forEach((e=>{`${e.meshGroup}`===t&&e.setMaterialsUniform(s)}))}}bindAppEventsToTextureQuality(){let e=0;this.bindings.push(this.appData.onPropertyChanged("phase",(()=>this.updateMaxQuality({}))),this.meshData.onChanged((t=>{t.meshTextureOpacity!==e&&this.updateMaxQuality({}),e=t.meshTextureOpacity})),this.engine.subscribe(b.Z,(e=>{this.startOpacityTransition(),this.updateMaxQuality({criticalChange:!0,modeChange:e.toMode})})),this.engine.subscribe(k.Z,(e=>{this.updateMaxQuality({criticalChange:!1,modeChange:e.toMode})})),this.engine.subscribe(v.oR,(()=>{this.updateMaxQuality({criticalChange:!0})})),this.engine.subscribe(v.NR,(()=>{this.updateMaxQuality({criticalChange:!1})})),this.engine.subscribe(f.Z,(()=>{this.updateMaxQuality({criticalChange:!0})})),this.engine.subscribe(y.Z,(e=>{this.sweepData.getSweep(e.toSweep).isAligned()||this.setMeshOpacity(0)})),this.engine.subscribe(M.Z,(()=>{this.updateMaxQuality({criticalChange:!1})})),this.engine.subscribe(l.m,(e=>{this.updateMaxQuality({interactionChange:e.mode})})))}async setPreviewPosition(e){const t=e.enabled&&e.previewCirclePosition?e.previewCirclePosition:null,s=e.size?e.size:.3;for(const e of this.modelMesh.chunks)e.setMeshPreviewSphere(t,s)}}},51344:(e,t,s)=>{"use strict";s.r(t),s.d(t,{createModelMesh:()=>x});var r=s(93331),i=s(84561),a=s(17915),o=s(31102);class MeshCreationException extends o.y{constructor(e){super(e),this.name="MeshCreationException"}}var n=s(2212),h=s(21922),d=s(38493);class FloorMesh extends n.Object3D{constructor(e,t=i.o.ALL){super(),this.renderLayer=t,this.roomMeshes=new d.Z((e=>e.meshSubgroup)),this.boundingBox=new n.Box3,this.size=new n.Vector3,this.center=new n.Vector3,this._chunks=[],this.built=!1,this.name=`FloorMesh:${e}`,this.meshGroup=e,this.floorId=void 0}dispose(){this.reset(),this.roomMeshes.clear()}reset(){for(const e of this.roomMeshes)e.dispose(),this.remove(e);this._chunks.length=0,this.built=!1}addChunk(e){const t=this.getOrCreateRoomMesh(e.meshSubgroup);this._chunks.push(e),t.addChunk(e)}build(){if(this.built)throw new Error("build() should only be called once");this.boundingBox.makeEmpty();for(const e of this.roomMeshes)this.add(e),this.boundingBox.union(e.boundingBox);this.center=this.boundingBox.getCenter(this.center),this.size=this.boundingBox.getSize(this.size),this.built=!0}get chunks(){return this._chunks}getOrCreateRoomMesh(e){let t=this.roomMeshes.get(e);return t||(t=new h.g(this.meshGroup,e,this.renderLayer),this.roomMeshes.add(t),this.add(t)),t}}var u=s(62955),l=s(6559),c=s(88512),m=s(2388),p=s(3614),g=s(19131);const f=new c.Z("dam-loader");class DamLoader{constructor(){this.decoder=s(92011).uO}async load(e,t,s){f.time("download");const r=await t.getFile(e,{responseType:"arraybuffer",onProgress:s});return f.timeEnd("download"),this.parse(r)}parse(e){f.time("parse proto");const t=this.decoder.read(new p(e));f.timeEnd("parse proto"),f.time("convert to webgl");const s=this.convertProtobufToSceneObject(t);return f.timeEnd("convert to webgl"),s}convertProtobufToSceneObject(e){if(0===e.chunk.length)return f.warn("No chunks in damfile..."),[];const t=new n.Matrix4;return t.set(1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1),e.chunk.map((function(e){const s=new n.BufferGeometry;s.setAttribute("position",new n.BufferAttribute(new Float32Array(e.vertices.xyz,0,3),3)),e.vertices.uv.length>0&&s.setAttribute("uv",new n.BufferAttribute(new Float32Array(e.vertices.uv,0,2),2)),s.setIndex(new n.BufferAttribute(new Uint32Array(e.faces.faces,0,1),1)),s.applyMatrix4(t),s.computeBoundingBox();const{group:r,subgroup:i}=(0,g.xc)(e.chunk_name);return new a.z(r,i,s,e.material_name)}))}}var y=s(17916);const M=new c.Z("mesh");class ModelMeshDam extends u.e{constructor(e,t,s=i.o.ALL){super(),this.renderLayer=s,this.floorMeshes=new d.Z((e=>e.meshGroup)),this.built=!1,this.uuid=e,this.name=`ModelMesh:${e}`,this.signedUrls=t,this.layers.mask=s.mask}dispose(){this.floorMeshes.mapElements((e=>{e.dispose(),this.remove(e)})),this.floorMeshes.clear(),this._chunks.length=0,this.built=!1}reset(){this.floorMeshes.mapElements((e=>{e.reset(),this.remove(e)})),this._chunks.length=0,this.built=!1}async load(e={}){const{roomMeshData:t}=e;let s=e.chunks?e.chunks:await class ModelLoader{static async load(e,t,s,r=0){const i=new DamLoader;m.ZP.highQualityDam&&0===r&&(r=1);const a=(t.meshUrls?t.meshUrls:[{suffix:"_50k",extension:"dam"},{suffix:"",extension:"dam"}])[r];if(!a)return Promise.reject("No suitable model file found...");const{url:o,suffix:n,extension:h}=a,d=o?await o.get():`${e}${n}.${h}`;return i.load(d,t,s).catch((()=>this.load(e,t,s,++r)))}}.load(this.uuid,this.signedUrls,e.onProgress).catch((e=>{M.error(e);const t=e instanceof Error?e.message:"Failed to load model mesh";throw new MeshCreationException(t)}));if(0===s.length){M.warn("No geometry found for model, loading faux geometry, disabling outside view-mode");const e=new n.PlaneBufferGeometry(5,5,1,1);e.rotateX(-Math.PI/2),e.computeBoundingBox();const t=new a.z(0,0,e);t.forEachMaterial((e=>e.visible=!1)),s=[t]}s.forEach(((e,t)=>{this.addChunk(e)})),this.build(t)}addChunk(e){const t=this.getOrCreateFloorMesh(e.meshGroup);this._chunks.push(e),t.addChunk(e)}build(e){var t,s;if(this.built)throw new Error("build() should only be called once");let r=0,i=0;for(const e of this.floorMeshes){this.add(e);for(const i of e.roomMeshes)i.build(),i.geometry.boundsTree||null===(s=(t=i.geometry).computeBoundsTree)||void 0===s||s.call(t),r++;e.build(),i++}M.debug(`FloorMeshes: ${i} RoomMeshes: ${r} Chunks: ${this._chunks.length}`),this.boundingBox.makeEmpty();for(const e of this.floorMeshes)this.boundingBox.union(e.boundingBox);this.size=this.boundingBox.getSize(this.size),this.center=this.boundingBox.getCenter(this.center),e.root=this,e.floors=new Set(this.floorMeshes),e.rooms=this.roomMeshes,e.commit(),this.built=!0}get roomMeshes(){const e=new Set;for(const t of this.floorMeshes)for(const s of t.roomMeshes)e.add(s);return e}setSide(e){for(const t of this.floorMeshes)for(const s of t.roomMeshes)this.setSideRecursively(s,e)}initTextureLoader(e,t,s,r){e.setModel(this,this.chunks,t.textures);const i=r.streamingTextures?(0,l.qT)().min(y.V.Standard):r.maxQuality;return e.loadAll(i).then((()=>{s()}))}registerCollision(e){e.registerMesh(this,!0);for(const t of this.roomMeshes)e.registerSnappingMeshGeometry(t.name,t.geometry)}onMeshIdsUpdated(e){for(const t of this.floorMeshes){for(const s of t.roomMeshes)s.floorId=e.floorIds[s.meshGroup],s.roomId=e.roomIds.get(s.meshGroup,s.meshSubgroup)||"";const s=e.floorIds[t.meshGroup];t.floorId=s}}setTextureQuality(e,t,s){e.setQuality(t,s)}onUpdate(){}setSideRecursively(e,t){e instanceof n.Mesh&&e.material&&e.material instanceof n.MeshBasicMaterial&&(e.material.side=t);for(const s of e.children)this.setSideRecursively(s,t)}getOrCreateFloorMesh(e){let t=this.floorMeshes.get(e);return t||(t=new FloorMesh(e,this.renderLayer),this.floorMeshes.add(t),this.add(t)),t}}async function x({uuid:e,urls:t,renderLayer:s,engine:i,roomMeshData:a}){const o=new ModelMeshDam(e,t,s);return await o.load({roomMeshData:a,onProgress:e=>{i.broadcast(new r.Z(e.loaded,e.total))}}),o}},59855:(e,t,s)=>{"use strict";s.d(t,{t:()=>a});var r=s(17597),i=s(20331);const a={urlTemplateToken:"<file>",hideMenu:"1"!==(0,r.eY)("dmenu","0"),debug:"1"===(0,r.eY)("debugTiles","0"),displayBoxBounds:!1,initialMaxDepth:0,maxDepth:Number((0,r.eY)("maxDepth","10")),loadSiblings:!0,displayActiveTiles:!1,autoDisableRendererCulling:!0,optimizeRaycast:!1,stopAtEmptyTiles:!1,statsTiles:!0,statsTextures:!1,statsTextureStream:!1,errorTarget:Number((0,r.eY)("errorTarget",4)),disableTileUpdates:!1,useOcclusionInfo:!0,disposeModel:!1,allocatedMegsBeforeLimitingLod:300,lruMinSize:0,lruMaxSize:800,lruUnloadPercent:.5,fixedMobileBudget:12,tileAssetRequestPriority:i.RequestPriority.MEDIUM,downloadQueueConcurrency:8,parseQueueConcurrency:10}},86980:(e,t,s)=>{"use strict";s.d(t,{e:()=>h,d:()=>d});var r=s(2212);const i=s(2388).ZP.sightingMaxAge,a=new r.Color;let o,n=-1;const h=(e,t)=>{o||(o=new r.InstancedMesh(new r.SphereBufferGeometry(.005,8,4),new r.MeshBasicMaterial,i),u(o));const s=new r.Matrix4;return({point:r,distance:h})=>{s.makeScale(h,h,h).setPosition(r),o.setMatrixAt(++n%i,s),o.instanceMatrix.needsUpdate=!0;for(let t=i;t--;)o.setColorAt((n-t+i)%i,a.set(e).multiplyScalar(1-t/i));o.instanceColor&&(o.instanceColor.needsUpdate=!0),o.parent||t.scene.add(o)}},d=()=>{var e;o&&(null===(e=o.parent)||void 0===e||e.remove(o),u(o))};function u(e){const t=(new r.Matrix4).makeScale(0,0,0);for(let s=0;s<i;s++)e.setMatrixAt(s,t)}},19131:(e,t,s)=>{"use strict";s.d(t,{xc:()=>i,ko:()=>a,k7:()=>o});var r=s(2212);function i(e){const t=e.match(/group([0-9]+)/),s=e.match(/sub([0-9]+)/),r=e.match(/type([0-9]+)/),i=e.match(/mirror([0-9]+)/),a=e.match(/window([0-9]+)/),o=e.match(/chunk([0-9]+)/),n=e.match(/_chunk([0-9]+)/),h=r?parseInt(r[1],10):i&&!isNaN(parseInt(i[1],10))?100:a&&!isNaN(parseInt(a[1],10))?101:0;return{group:t?parseInt(t[1],10):0,subgroup:s?parseInt(s[1],10):0,chunkIndex:o?parseInt(o[1],10):0,nodeIndex:n?parseInt(n[1],10):0,type:h}}function a(e,t=!1){let s=e.getAttribute("barycentric");if(s)return s;const i=(e.getIndex()||e.getAttribute("position")).count/3,a=[];for(let e=0;e<i;e++){const s=t?1:0;e%2==0?a.push(0,0,1,0,1,0,1,0,s):a.push(0,1,0,0,0,1,1,0,s)}const o=new Float32Array(a);return s=new r.BufferAttribute(o,3),e.setAttribute("barycentric",s),s}function o(e=16777215*Math.random(),t=1){const s=function(e,t,s,r=1){const i=document.createElement("canvas");i.width=t,i.height=s;const a=i.getContext("2d");return a.fillStyle=`rgba(${255*e.r|0},${255*e.g|0},${255*e.b|0}, ${255*r|0})`,a.fillRect(0,0,t,s),i}(new r.Color(e),1,1,t),i=new r.CubeTexture([s,s,s,s,s,s]);return i.format=r.RGBAFormat,i.needsUpdate=!0,i}},64807:(e,t,s)=>{"use strict";s.d(t,{Z:()=>PanoRenderTargetResizedMessage});var r=s(91466);class PanoRenderTargetResizedMessage extends r.v{constructor(e,t,s){super(),this.size=e,this.sweepId=t,this.renderTarget=s}}}}]);